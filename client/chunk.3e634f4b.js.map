{"version":3,"file":"chunk.3e634f4b.js","sources":["../../../node_modules/svelte/transition.mjs"],"sourcesContent":["import { cubicOut, cubicInOut } from './easing';\nimport { assign, is_function } from './internal';\n\nexport function fade(node, {\n\tdelay = 0,\n\tduration = 400\n}) {\n\tconst o = +getComputedStyle(node).opacity;\n\n\treturn {\n\t\tdelay,\n\t\tduration,\n\t\tcss: t => `opacity: ${t * o}`\n\t};\n}\n\nexport function fly(node, {\n\tdelay = 0,\n\tduration = 400,\n\teasing = cubicOut,\n\tx = 0,\n\ty = 0,\n\topacity = 0\n}) {\n\tconst style = getComputedStyle(node);\n\tconst target_opacity = +style.opacity;\n\tconst transform = style.transform === 'none' ? '' : style.transform;\n\n\tconst od = target_opacity * (1 - opacity);\n\n\treturn {\n\t\tdelay,\n\t\tduration,\n\t\teasing,\n\t\tcss: (t, u) => `\n\t\t\ttransform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);\n\t\t\topacity: ${target_opacity - (od * u)}`\n\t};\n}\n\nexport function slide(node, {\n\tdelay = 0,\n\tduration = 400,\n\teasing = cubicOut\n}) {\n\tconst style = getComputedStyle(node);\n\tconst opacity = +style.opacity;\n\tconst height = parseFloat(style.height);\n\tconst padding_top = parseFloat(style.paddingTop);\n\tconst padding_bottom = parseFloat(style.paddingBottom);\n\tconst margin_top = parseFloat(style.marginTop);\n\tconst margin_bottom = parseFloat(style.marginBottom);\n\tconst border_top_width = parseFloat(style.borderTopWidth);\n\tconst border_bottom_width = parseFloat(style.borderBottomWidth);\n\n\treturn {\n\t\tdelay,\n\t\tduration,\n\t\teasing,\n\t\tcss: t =>\n\t\t\t`overflow: hidden;` +\n\t\t\t`opacity: ${Math.min(t * 20, 1) * opacity};` +\n\t\t\t`height: ${t * height}px;` +\n\t\t\t`padding-top: ${t * padding_top}px;` +\n\t\t\t`padding-bottom: ${t * padding_bottom}px;` +\n\t\t\t`margin-top: ${t * margin_top}px;` +\n\t\t\t`margin-bottom: ${t * margin_bottom}px;` +\n\t\t\t`border-top-width: ${t * border_top_width}px;` +\n\t\t\t`border-bottom-width: ${t * border_bottom_width}px;`\n\t};\n}\n\nexport function scale(node, {\n\tdelay = 0,\n\tduration = 400,\n\teasing = cubicOut,\n\tstart = 0,\n\topacity = 0\n}) {\n\tconst style = getComputedStyle(node);\n\tconst target_opacity = +style.opacity;\n\tconst transform = style.transform === 'none' ? '' : style.transform;\n\n\tconst sd = 1 - start;\n\tconst od = target_opacity * (1 - opacity);\n\n\treturn {\n\t\tdelay,\n\t\tduration,\n\t\teasing,\n\t\tcss: (t, u) => `\n\t\t\ttransform: ${transform} scale(${1 - (sd * u)});\n\t\t\topacity: ${target_opacity - (od * u)}\n\t\t`\n\t};\n}\n\nexport function draw(node, {\n\tdelay = 0,\n\tspeed,\n\tduration,\n\teasing = cubicInOut\n}) {\n\tconst len = node.getTotalLength();\n\n\tif (duration === undefined) {\n\t\tif (speed === undefined) {\n\t\t\tduration = 800;\n\t\t} else {\n\t\t\tduration = len / speed;\n\t\t}\n\t} else if (typeof duration === 'function') {\n\t\tduration = duration(len);\n\t}\n\n\treturn {\n\t\tdelay,\n\t\tduration,\n\t\teasing,\n\t\tcss: (t, u) => `stroke-dasharray: ${t * len} ${u * len}`\n\t};\n}\n\nexport function crossfade({ fallback, ...defaults }) {\n\tconst to_receive = new Map();\n\tconst to_send = new Map();\n\n\tfunction crossfade(from, node, params) {\n\t\tconst {\n\t\t\tdelay = 0,\n\t\t\tduration = d => Math.sqrt(d) * 30,\n\t\t\teasing = cubicOut\n\t\t} = assign(assign({}, defaults), params);\n\n\t\tconst to = node.getBoundingClientRect();\n\t\tconst dx = from.left - to.left;\n\t\tconst dy = from.top - to.top;\n\t\tconst d = Math.sqrt(dx * dx + dy * dy);\n\n\t\tconst style = getComputedStyle(node);\n\t\tconst transform = style.transform === 'none' ? '' : style.transform;\n\t\tconst opacity = +style.opacity;\n\n\t\treturn {\n\t\t\tdelay,\n\t\t\tduration: is_function(duration) ? duration(d) : duration,\n\t\t\teasing,\n\t\t\tcss: (t, u) => `\n\t\t\t\topacity: ${t * opacity};\n\t\t\t\ttransform: ${transform} translate(${u * dx}px,${u * dy}px);\n\t\t\t`\n\t\t};\n\t}\n\n\tfunction transition(items, counterparts, intro) {\n\t\treturn (node, params) => {\n\t\t\titems.set(params.key, {\n\t\t\t\trect: node.getBoundingClientRect()\n\t\t\t});\n\n\t\t\treturn () => {\n\t\t\t\tif (counterparts.has(params.key)) {\n\t\t\t\t\tconst { rect } = counterparts.get(params.key);\n\t\t\t\t\tcounterparts.delete(params.key);\n\n\t\t\t\t\treturn crossfade(rect, node, params);\n\t\t\t\t}\n\n\t\t\t\t// if the node is disappearing altogether\n\t\t\t\t// (i.e. wasn't claimed by the other list)\n\t\t\t\t// then we need to supply an outro\n\t\t\t\titems.delete(params.key);\n\t\t\t\treturn fallback && fallback(node, params, intro);\n\t\t\t};\n\t\t};\n\t}\n\n\treturn [\n\t\ttransition(to_send, to_receive, false),\n\t\ttransition(to_receive, to_send, true)\n\t];\n}"],"names":["fade","node","delay","duration","o","getComputedStyle","opacity","css","t"],"mappings":"4BAGO,SAASA,EAAKC,GAAMC,MAC1BA,EAAQ,EAACC,SACTA,EAAW,MAEX,MAAMC,GAAKC,iBAAiBJ,GAAMK,QAElC,MAAO,CACNJ,MAAAA,EACAC,SAAAA,EACAI,IAAKC,eAAiBA,EAAIJ"}