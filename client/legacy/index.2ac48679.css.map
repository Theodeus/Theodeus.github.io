{
  "version": 3,
  "file": "index.2ac48679.css",
  "sources": [
    "..\\..\\..\\..\\..\\..\\..\\src\\routes\\index.svelte"
  ],
  "sourcesContent": [
    "<script>\r\n  import { onMount } from \"svelte\";\r\n  import { fade } from \"svelte/transition\";\r\n\r\n  let canvas, offscreenCanvas, ctx, offscreenCtx, i, prevX, prevY;\r\n  let innerWidth;\r\n  let innerHeight;\r\n  let current;\r\n  let mounted = false;\r\n  let strokes;\r\n  let brushRadiusX;\r\n  let brushRadiusY;\r\n\r\n  let clientX;\r\n  let clientY;\r\n\r\n  let frames = 0;\r\n\r\n  let update = event => {\r\n    clientX = event.clientX;\r\n    clientY = event.clientY;\r\n    if (isNaN(clientX) || isNaN(clientY)) {\r\n      if (event.touches) {\r\n        if (\r\n          event.touches[0] &&\r\n          event.touches[0].clientX &&\r\n          event.touches[0].clientY\r\n        ) {\r\n          return requestAnimationFrame(\r\n            startTouch.bind(\r\n              null,\r\n              event.touches[0].clientX,\r\n              event.touches[0].clientY\r\n            )\r\n          );\r\n        }\r\n      } else {\r\n        return;\r\n      }\r\n    }\r\n    current.forEach(brush => {\r\n      for (i = 0; i < strokes; i++) {\r\n        offscreenCtx.lineWidth = Math.random() * 70 + 10;\r\n        offscreenCtx.beginPath();\r\n        brush.x = clientX + (Math.random() * 100 - 50);\r\n        brush.y = clientY + (Math.random() * 100 - 50);\r\n        offscreenCtx.fillStyle = `rgba(${~~(\r\n          (brush.x / innerWidth) *\r\n          255\r\n        )}, ${~~((brush.y / innerHeight) * 255)}, 150, 0.2)`;\r\n        offscreenCtx.ellipse(\r\n          brush.x,\r\n          brush.y,\r\n          brushRadiusX,\r\n          brushRadiusY,\r\n          (Math.random() * 6) / Math.PI,\r\n          0,\r\n          2 * Math.PI\r\n        );\r\n        offscreenCtx.fill();\r\n        offscreenCtx.closePath();\r\n      }\r\n    });\r\n    ctx.save();\r\n    ctx.filter = \"blur(250px)\";\r\n    ctx.drawImage(offscreenCanvas, 0, 0);\r\n    ctx.restore();\r\n    ctx.fillStyle = \"rgba(30, 30, 30, 0.3\";\r\n    ctx.fillRect(0, 0, innerWidth, innerHeight);\r\n  };\r\n\r\n  let startTouch = (x, y) => {\r\n    for (let i = 0; i < 25; i++) {\r\n      setTimeout(update({ clientX: x + i * 10, clientY: y + i * 10 }), i * 16);\r\n    }\r\n  };\r\n\r\n  onMount(() => {\r\n    mounted = true;\r\n  });\r\n\r\n  $: if (innerWidth && mounted) {\r\n    strokes = 10;\r\n    offscreenCanvas = document.createElement(\"canvas\");\r\n    canvas.width = innerWidth;\r\n    offscreenCanvas.width = innerWidth + 100;\r\n    canvas.height = innerHeight;\r\n    offscreenCanvas.height = innerHeight + 100;\r\n    brushRadiusX = innerWidth / 35;\r\n    brushRadiusY = innerHeight / 35;\r\n    current = [\r\n      {\r\n        x: innerWidth / 2,\r\n        y: innerHeight / 2\r\n      },\r\n      {\r\n        x: innerWidth / 2,\r\n        y: innerHeight / 2\r\n      },\r\n      {\r\n        x: innerWidth / 2,\r\n        y: innerHeight / 2\r\n      },\r\n      {\r\n        x: innerWidth / 2,\r\n        y: innerHeight / 2\r\n      },\r\n      {\r\n        x: innerWidth / 2,\r\n        y: innerHeight / 2\r\n      }\r\n    ];\r\n    ctx = canvas.getContext(\"2d\");\r\n    offscreenCtx = offscreenCanvas.getContext(\"2d\");\r\n  }\r\n</script>\r\n\r\n<style>\r\n  p {\r\n    text-align: center;\r\n    margin: 1em auto;\r\n  }\r\n  a {\r\n    font-size: 3em;\r\n    padding: 30px;\r\n  }\r\n  a::selection {\r\n    background: #990099;\r\n    color: #bb0099;\r\n  }\r\n  a:hover {\r\n    color: #555;\r\n  }\r\n  canvas {\r\n    position: fixed;\r\n    overflow: hidden;\r\n    top: 0;\r\n    left: 0;\r\n    z-index: -1;\r\n  }\r\n</style>\r\n\r\n<svelte:window bind:innerWidth bind:innerHeight />\r\n<svelte:body\r\n  on:mousemove={update}\r\n  on:touchstart={update}\r\n  on:touchmove={update} />\r\n\r\n<svelte:head>\r\n  <title>Oskar Eriksson | Interactive Developer & Technical Director</title>\r\n</svelte:head>\r\n\r\n<canvas bind:this={canvas} />\r\n\r\n<header>\r\n  <p>\r\n    <a\r\n      in:fade={{ duration: 2000 }}\r\n      href=\"mailto:oskar@oskareriksson.se\"\r\n      target=\"_blank\">\r\n      Mail\r\n    </a>\r\n    <a\r\n      in:fade={{ duration: 2000 }}\r\n      href=\"https://github.com/theodeus\"\r\n      target=\"_blank\">\r\n      Github\r\n    </a>\r\n    <a\r\n      in:fade={{ duration: 2000 }}\r\n      href=\"https://twitter.com/_oskareriksson\"\r\n      target=\"_blank\">\r\n      Twitter\r\n    </a>\r\n    <a\r\n      in:fade={{ duration: 2000 }}\r\n      href=\"https://www.linkedin.com/in/oskar-eriksson-00422446/\"\r\n      target=\"_blank\">\r\n      LinkedIn\r\n    </a>\r\n  </p>\r\n</header>\r\n"
  ],
  "names": [],
  "mappings": "AAsHE,CAAC,cAAC,CAAC,AACD,UAAU,CAAE,MAAM,CAClB,MAAM,CAAE,GAAG,CAAC,IAAI,AAClB,CAAC,AACD,CAAC,cAAC,CAAC,AACD,SAAS,CAAE,GAAG,CACd,OAAO,CAAE,IAAI,AACf,CAAC,AACD,eAAC,WAAW,AAAC,CAAC,AACZ,UAAU,CAAE,OAAO,CACnB,KAAK,CAAE,OAAO,AAChB,CAAC,AACD,eAAC,MAAM,AAAC,CAAC,AACP,KAAK,CAAE,IAAI,AACb,CAAC,AACD,MAAM,cAAC,CAAC,AACN,QAAQ,CAAE,KAAK,CACf,QAAQ,CAAE,MAAM,CAChB,GAAG,CAAE,CAAC,CACN,IAAI,CAAE,CAAC,CACP,OAAO,CAAE,EAAE,AACb,CAAC"
}